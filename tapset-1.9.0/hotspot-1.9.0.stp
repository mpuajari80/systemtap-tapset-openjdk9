
/* hotspot.class_loaded
   Triggers when a class is loaded.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class and is_shared if the
   class was loaded from a shared archive.
   
   For more information please refer to
   hotspot/src/share/vm/services/classLoadingService.cpp
 */
probe hotspot.class_loaded =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("class__loaded"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("class__loaded")
{
  name = "class_loaded";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  is_shared = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,is_shared=%d)",
                     name, class, classloader_id, is_shared);
}

/* hotspot.class_unloaded
   Triggers when a class is unloaded.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   is_shared will be false as classes that can be unloaded 
   must be non-shared (refer classLoadingService.cpp)

   For more information please refer to
   hotspot/src/share/vm/services/classLoadingService.cpp
 */
probe hotspot.class_unloaded =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("class__unloaded"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("class__unloaded")
{
  name = "class_unloaded";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  is_shared = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,is_shared=%d)",
                     name, class, classloader_id, is_shared);
}

/* hotspot.class_initialization_required
   Triggers when a class initialization is required.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_required =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__required"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__required")
{
  name = "class_initialization_required";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d)",
                     name, class, classloader_id, thread_type);
}

/* hotspot.class_initialization_recursive
   Triggers when a class initialization is recursive.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_recursive =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__recursive"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__recursive")
{
  name = "class_initialization_recursive";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_concurrent
   // TODO write document about probe
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_concurrent =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__concurrent"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__concurrent")
{
  name = "class_initialization_concurrent";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_erroneous
   Triggers when class could not be initialized and is in error state.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_erroneous =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__erroneous"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__erroneous")
{
  name = "class_initialization_erroneous";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_super_failed
   Triggers when class could not be initialized because of super failed.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_super_failed =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__super__failed"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__super__failed")
{
  name = "class_initialization_super_failed";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_clinit
   Triggers when class is initialized.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_clinit =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__clinit"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__clinit")
{
  name = "class_initialization_clinit";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_error
   Triggers when class initialization has errors
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_error =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__error"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__error")
{
  name = "class_initialization_error";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_end
   Triggers when class initialization ends
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_end =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__end"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__end")
{
  name = "class_initialization_end";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.vm_init_begin
   Triggers at the beginning of the virtual machine initialization.
   Has no arguments

   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.vm_init_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__init__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__init__begin")
{
  name = "vm_init_begin";
  probestr = name;
}

/* hotspot.vm_init_end
   Triggers at the end of the virtual machine initialization.
   Has no arguments.
   
   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.vm_init_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__init__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__init__end")
{
  name = "vm_init_end";
  probestr = name;
}

/* hotspot.vm_shutdown
   Triggers at the shutdown of the virtual machine.
   Has no arguments.
   
   For more information please refer to
   hotspot/src/share/vm/runtime/java.cpp
 */
probe hotspot.vm_shutdown =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__shutdown"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__shutdown")
{
  name = "vm_shutdown";
  probestr = name;
}

/* hotspot.vmops_request
   Triggers when vm operation is requested.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vm_shutdown =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__request"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__request")
{
  name = "vmops_request"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evalution_mode);
}

/* hotspot.vmops_request
   Triggers when vm operation is requested.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_request =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__request"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__request")
{
  name = "vmops_request"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.vmops_begin
   Triggers when vm operation begins.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__begin")
{
  name = "vmops_begin"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.vmops_end
   Triggers when vm operation ends.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__end")
{
  name = "vmops_end"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.gc_begin
   Triggers for GC begins
   gc_full GC is full or not
   
   For more information please refer to
   hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp
 */
probe hotspot.gc_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("gc__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("gc__begin")
{
  name = "gc_begin"
  gc_full = $arg1;
  probestr = sprintf("%s(gc_full=%d)", gc_full);
}

/* hotspot.gc_end
   Triggers for GC ends
   gc_full GC is full or not
   
   For more information please refer to
   hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp
 */
probe hotspot.gc_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("gc__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("gc__end")
{
  name = "gc_end"
  probestr = sprintf("%s", name);
}

