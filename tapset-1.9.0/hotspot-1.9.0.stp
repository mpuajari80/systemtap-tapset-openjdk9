
/* hotspot.class_loaded
   Triggers when a class is loaded.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class and is_shared if the
   class was loaded from a shared archive.
   
   For more information please refer to
   hotspot/src/share/vm/services/classLoadingService.cpp
 */
probe hotspot.class_loaded =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("class__loaded"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("class__loaded")
{
  name = "class_loaded";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  is_shared = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,is_shared=%d)",
                     name, class, classloader_id, is_shared);
}

/* hotspot.class_unloaded
   Triggers when a class is unloaded.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   is_shared will be false as classes that can be unloaded 
   must be non-shared (refer classLoadingService.cpp)

   For more information please refer to
   hotspot/src/share/vm/services/classLoadingService.cpp
 */
probe hotspot.class_unloaded =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("class__unloaded"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("class__unloaded")
{
  name = "class_unloaded";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  is_shared = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,is_shared=%d)",
                     name, class, classloader_id, is_shared);
}

/* hotspot.class_initialization_required
   Triggers when a class initialization is required.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_required =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__required"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__required")
{
  name = "class_initialization_required";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d)",
                     name, class, classloader_id, thread_type);
}

/* hotspot.class_initialization_recursive
   Triggers when a class initialization is recursive.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_recursive =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__recursive"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__recursive")
{
  name = "class_initialization_recursive";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_concurrent
   // TODO write document about probe
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_concurrent =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__concurrent"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__concurrent")
{
  name = "class_initialization_concurrent";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_erroneous
   Triggers when class could not be initialized and is in error state.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_erroneous =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__erroneous"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__erroneous")
{
  name = "class_initialization_erroneous";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_super_failed
   Triggers when class could not be initialized because of super failed.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_super_failed =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__super__failed"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__super__failed")
{
  name = "class_initialization_super_failed";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_clinit
   Triggers when class is initialized.
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_clinit =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__clinit"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__clinit")
{
  name = "class_initialization_clinit";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_error
   Triggers when class initialization has errors
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_error =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__error"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__error")
{
  name = "class_initialization_error";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.class_initialization_end
   Triggers when class initialization ends
   name to the loaded class name, classloader_id to the id
   of the classloader that loaded this class 
   thread_type its set to -1 (ref hotspot/src/share/vm/oops/instanceKlass.cpp)
   wait will be wait or not

   For more information please refer to
   hotspot/src/share/vm/oops/instanceKlass.cpp
 */
probe hotspot.class_initialization_end =
 process("@ABS_CLIENT_LIBJVM_SO@").mark("class__initialization__end"),
 process("@ABS_SERVER_LIBJVM_SO@").mark("class__initialization__end")
{
  name = "class_initialization_end";
  class = user_string_n($arg1, $arg2);
  classloader_id = $arg3;
  thread_type = $arg4;
  wait = $arg5;
  probestr = sprintf("%s(class='%s',classloader_id=0x%x,thread_type=%d,wait=%d)",
                     name, class, classloader_id, thread_type, wait);
}

/* hotspot.vm_init_begin
   Triggers at the beginning of the virtual machine initialization.
   Has no arguments

   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.vm_init_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__init__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__init__begin")
{
  name = "vm_init_begin";
  probestr = name;
}

/* hotspot.vm_init_end
   Triggers at the end of the virtual machine initialization.
   Has no arguments.
   
   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.vm_init_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__init__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__init__end")
{
  name = "vm_init_end";
  probestr = name;
}

/* hotspot.vm_shutdown
   Triggers at the shutdown of the virtual machine.
   Has no arguments.
   
   For more information please refer to
   hotspot/src/share/vm/runtime/java.cpp
 */
probe hotspot.vm_shutdown =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vm__shutdown"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vm__shutdown")
{
  name = "vm_shutdown";
  probestr = name;
}

/* hotspot.vmops_request
   Triggers when vm operation is requested.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vm_shutdown =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__request"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__request")
{
  name = "vmops_request"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evalution_mode);
}

/* hotspot.vmops_request
   Triggers when vm operation is requested.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_request =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__request"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__request")
{
  name = "vmops_request"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.vmops_begin
   Triggers when vm operation begins.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__begin")
{
  name = "vmops_begin"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.vmops_end
   Triggers when vm operation ends.
   opname name of the operation, evaluation_mode
   
   For more information please refer to
   hotspot/src/share/vm/runtime/vmThread.cpp
 */
probe hotspot.vmops_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("vmops__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("vmops__end")
{
  name = "vmops_end"
  opname = user_string_n($arg1, $arg2);
  evaluation_mode = $arg3;
  probestr = sprintf("%s(opname='%s',evalution_mode=%d)",
                     name, opname, evaluation_mode);
}

/* hotspot.gc_begin
   Triggers for GC begins
   gc_full GC is full or not
   
   For more information please refer to
   hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp
 */
probe hotspot.gc_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("gc__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("gc__begin")
{
  name = "gc_begin"
  gc_full = $arg1;
  probestr = sprintf("%s(gc_full=%d)", gc_full);
}

/* hotspot.gc_end
   Triggers for GC ends
   gc_full GC is full or not
   
   For more information please refer to
   hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp
 */
probe hotspot.gc_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("gc__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("gc__end")
{
  name = "gc_end"
  probestr = sprintf("%s", name);
}

/* hotspot.mem_pool_gc_begin
   Triggers when a memory pool collection begins.
   Sets manager to the manager name that controls this memory pool
   (e.g. 'Copy' or 'MarkSweepCompact'), pool to the pool name (e.g.
   'Code Cache', 'Eden Space', 'Survivor Space', 'Tenured Gen', or
   'Perm Gen'), initial to the initial byte size of the pool, used
   to the number bytes in use, committed to the number of committed
   pages and max to the maximum size of the pool.

   For more information please refer to
   hotspot/src/share/vm/services/memoryManager.cpp
 */
probe hotspot.mem_pool_gc_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("mem__pool__gc__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("mem__pool__gc__begin")
{
  name = "mem_pool_gc_begin";
  manager = user_string_n($arg1, $arg2);
  pool = user_string_n($arg3, $arg4);
  initial = $arg5;
  used = $arg6;
  committed = $arg7;
  max = $arg8;
  probestr = sprintf("%s(manager='%s',pool='%s',initial=%d,used=%d,committed=%d,max=%d)",
                     name, manager, pool, initial, used, committed, max);
}

/* hotspot.mem_pool_gc_end
   Triggers when a memory pool collection ends.
   Sets manager to the manager name that controls this memory pool
   (e.g. 'Copy' or 'MarkSweepCompact'), pool to the pool name (e.g.
   'Code Cache', 'Eden Space', 'Survivor Space', 'Tenured Gen', or
   'Perm Gen'), initial to the initial byte size of the pool, used
   to the number bytes in use, committed to the number of committed
   pages and max to the maximum size of the pool.

   For more information please refer to
   hotspot/src/share/vm/services/memoryManager.cpp
 */
probe hotspot.mem_pool_gc_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("mem__pool__gc__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("mem__pool__gc__end")
{
  name = "mem_pool_gc_end";
  manager = user_string_n($arg1, $arg2);
  pool = user_string_n($arg3, $arg4);
  initial = $arg5;
  used = $arg6;
  committed = $arg7;
  max = $arg8;
  probestr = sprintf("%s(manager='%s',pool='%s',initial=%d,used=%d,committed=%d,max=%d)",
                     name, manager, pool, initial, used, committed, max);
}

/* hotspot.thread_start
   Triggers when a java thread is started.
   Sets name to the name of the thread, id to the java thread id,
   native_id to the os thread number and is_daemon if the thread
   is a daemon thread.

   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.thread_start =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__start"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__start")
{
  name = "thread_start";
  thread_name = user_string_n($arg1, $arg2);
  id = $arg3;
  native_id = $arg4;
  is_daemon = $arg5;
  probestr = sprintf("%s(thread_name='%s',id=%d,native_id=%d,is_daemon=%d)",
                     name, thread_name, id, native_id, is_daemon);
}

/* hotspot.thread_stop
   Triggers when a java thread stops.
   Sets name to the name of the thread, id to the java thread id,
   native_id to the os thread number and is_daemon if the thread
   is a daemon thread.

   For more information please refer to
   hotspot/src/share/vm/runtime/thread.cpp
 */
probe hotspot.thread_stop =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__stop"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__stop")
{
  name = "thread_stop";
  thread_name = user_string_n($arg1, $arg2);
  id = $arg3;
  native_id = $arg4;
  is_daemon = $arg5;
  probestr = sprintf("%s(thread_name='%s',id=%d,native_id=%d,is_daemon=%d)",
                     name, thread_name, id, native_id, is_daemon);
}

/* hotspot.thread_sleep_begin
   Triggers when thread sleep begins.
   sleep_millis sleep time in millis

   For more information please refer to
   hotspot/src/share/vm/prims/jvm.cpp
 */
probe hotspot.thread_sleep_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__sleep__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__sleep__begin")
{
  name = "thread_sleep_begin";
  sleep_millis = $arg1;
  probestr = sprintf("%s(sleep_millis='%d')", name, sleep_millis);
}

/* hotspot.thread_sleep_end
   Triggers when thread sleep ends.
   Interrupted 1 means sleep was interuppted

   For more information please refer to
   hotspot/src/share/vm/prims/jvm.cpp
 */
probe hotspot.thread_sleep_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__sleep__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__sleep__end")
{
  name = "thread_sleep_end";
  interrupted = $arg1;
  probestr = sprintf("%s(interrupted='%d')", name, interrupted);
}

/* hotspot.thread_yield
   Triggers when thread yields.

   For more information please refer to
   hotspot/src/share/vm/prims/jvm.cpp
 */
probe hotspot.thread_yield =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__yield"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__yield")
{
  name = "thread_yield";
  probestr = sprintf("%s", name);
}

/* hotspot.thread_park_begin
   Triggers thread is parked
   Parker, is_absolute, time

   For more information please refer to
   hotspot/src/share/vm/prims/unsafe.cpp
 */
probe hotspot.thread_park_begin =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__park__begin"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__park__begin")
{
  name = "thread_park_begin";
  parker = $arg1;
  is_absolute = $arg2;
  time = $arg3;
  probestr = sprintf("%s(parker='%d',is_absoulte=%d,time=%d)",
                     name, parker, is_absolute, time);
}

/* hotspot.thread_park_end
   Triggers when park is end
   Parker

   For more information please refer to
   hotspot/src/share/vm/prims/unsafe.cpp
 */
probe hotspot.thread_park_end =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__park__end"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__park__end")
{
  name = "thread_park_end";
  parker = $arg1;
  probestr = sprintf("%s(parker='%d')", name, parker);
}

/* hotspot.thread_unpark
   Triggers parker is unparked
   Parker

   For more information please refer to
   hotspot/src/share/vm/prims/unsafe.cpp
 */
probe hotspot.thread_unpark =
  process("@ABS_CLIENT_LIBJVM_SO@").mark("thread__unpark"),
  process("@ABS_SERVER_LIBJVM_SO@").mark("thread__unpark")
{
  name = "thread_unpark";
  parker = $arg1;
  probestr = sprintf("%s(parker='%d')", name, parker);
}

